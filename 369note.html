<!DOCTYPE HTML>

<head>
  <meta charset="utf-8">
  <title>YUE LI's personal website</title>
  <meta name="author" content="YUE LI">
  <meta name="description" content="YUE Li's personal website">
  <meta name="Copyright" content="YUE LI">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />

  <link rel="stylesheet" href="styles/style.css">
  <link rel="stylesheet" href="styles/prism.css"/>

  <script src="js/prism.js" type="text/javascript" async></script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
  <header>
    <nav>
      <h1><span class="mobile-word">Notes for CSC</span><span class="desktop-word">Yue's notes for CSC369: Operating System</span></h1>
      <div id="navbar">
		<ul class="main-nav">
			<li><a href="http://www.lhzuigao.com">Home</a></li>
			<li><a href="#">By Time</a>
				<ul> <!--use different text on different device-->
          <!--only first two weeks' links work, more would be added later-->
					<li><a href="#week1"><span class="mobile-word">Week1</span>
            <span class="desktop-word">Week1: Intro to OS, Processes, threads</span></a></li>
					<li><a href="#week2"><span class="mobile-word">Week2</span>
            <span class="desktop-word">Week2: System calls, intro to synchronization</span></a></li>
					<li><a href="#week3"><span class="mobile-word">Week3</span>
            <span class="desktop-word">Week3: Synchronization, intro to scheduling </span></a></li>
					<li><a href="#week4"><span class="mobile-word">Week4</span>
            <span class="desktop-word">Week4:</span></a></li>
					<li><a href="#week5"><span class="mobile-word">Week5</span>
            <span class="desktop-word">Week5:</span></a></li>
					<li><a href="#week6"><span class="mobile-word">Week6</span>
            <span class="desktop-word">Week6:</span></a></li>
					<li><a href="#week7"><span class="mobile-word">Week7</span>
            <span class="desktop-word">Week7:</span></a></li>
					<li><a href="#week8"><span class="mobile-word">Week8</span>
            <span class="desktop-word">Week8:</span></a></li>
					<li><a href="#week9"><span class="mobile-word">Week9</span>
            <span class="desktop-word">Week9:</span></a></li>
					<li><a href="#week10"><span class="mobile-word">Week10</span>
            <span class="desktop-word">Week10:</span></a></li>
					<li><a href="#week11"><span class="mobile-word">Week11</span>
            <span class="desktop-word">Week11:</span></a></li>
					<li><a href="#week12"><span class="mobile-word">Week12</span>
            <span class="desktop-word">Week12:</span></a></li>
				</ul>
			</li>
			<li><a href="#">By Topic</a>
				<ul>
					<li><a href="#"></a></li>
					<li><a href="#"></a></li>
					<li><a href="#"></a></li>
					<li><a href="#"></a></li>
				</ul>
			</li>
    </ul>
      </div>
    </nav>
  </header>


  <section>
    <div id="introduction">
      <h3>Introduction</h3>
      <p>
         The course covers the operating system as a control program and
         resource allocator; processes, threads, and concurrency; memory
         management; file systems; and protection. It is one of the requirment
         for all computer science specialists.
      </p>
    </div>
  </section>


    <div id="content">

      <section id="week1">
        <h3>WEEK1: Intro to OS, Processes, threads</h3>
        <div class="block" id="os_intro">
          <h4>Intro to OS</h4>
          <ul>
            <li>Regard OS as: abstraction provider, resource manager, program controller</li>
            <li>Kernel mode: Core to operating system, had the permission to
              access the OS. Normal prorgams are in user mode, which cannot access to the OS</li>
            <li>About the storage: </li>
            <li><img src="imgs/storage.png" alt="storage" style="width:50%;height:50%;"> </li>
            <li>Concurrency: problem caused by multiple processes executes concurrently.</li>
          </ul>
          <hr>
        </div>

        <div class="block" id="process">
          <h4>Processes and threads</h4>
          <ul>
            <li>Process: a prorgam in exexution, its like a container that
              contains all <strong>execution states</strong> of program in execution, and
              is named by the PID</li>
            <li><img src="imgs/state_program.png" alt="programs state" style="width:50%;height:50%;"></li>
            <li>Process Control Block(PCB): process's data structure, contains
              all info about process, where OS keep all process' execution
              state(see the picture) when process not running</li>
            <li>Process state: ready/ blocked/ running</li>
            <li><img src="imgs/state.png" alt="state" style="width:50%;height:50%;"></li>
            <li>State queues: OS keep track of processes by a collection of queues, one queue for each state</li>
            <li><img src="imgs/state_queue.png" alt="state queue" style="width:50%;height:50%;"></li>
            <li>Context switch: switch the CPU to another process, save state of old process, load saved state for new process</li>
            <li>Opreations on processes:
              <ul>
                <li>process creation: process created by another process, fork (review in CSC209)</li>
                <li>process termination</li>
              </ul>
            </li>
            <li>Parallel prorgams: create several processes that execute in parallel/ shared memoru for processes to share data, OS schedule these processes in parallel. parallel program is <strong>INEFFICIENT</strong></li>
            <li>Parallel prorgams => cooperating processes share:<ul>
              <li>same code and data</li>
              <li>same privileges (what does that mean?)</li>
              <li>same resources</li>
            </ul>not share:<ul>
              <li>execution states like PC SP registers</li>
            </ul></li>
          </ul>
          <hr>
        </div>

        <div class="block" id="threads">
          <h4>Intro to Threads</h4>
          <ul>
            <li>Thread: defines a sequential execution stream within a process (PC, SP, registers). Bound to a single process, but sinle process can have multiple threads. Processes are containers in which threads execute.</li>
            <li>Thread interface(Pthread API)</li>
            <li>Thread scheduling => scheduler determines when a thread runs. Uses queues to keep track of what threads are doing. Run queue/ ready queue</li>
          </ul>
          <hr>
        </div>
	</section>

  <section id="week2">
    <h3>WEEK2:</h3>
    <div class="block" id="">
      <h4></h4>
      <ul>
        <li></li>
      </ul>
      <hr>
    </div>
  </section>

  <section id="week4">
    <h3>WEEK4: Scheduling</h3>

    <div class="block" id="dining_philo">
      <h4>Dining philosophers</h4>
      <ul>
        <li>A philosopher needs two forks to eat (one in his left, one in his
           right), there aren't enough forks for them to eat simultaneously</li>
        <li>Key to solve the problem is to deal with the limited forks, the forks
           are shared resources and we can apply semaphore here.</li>
        <li><img src="imgs/week5/d_ph_1.png" alt="philosopher function" style="width:100%;height:100%;"></li>
        <li><img src="imgs/week5/d_ph_2.png" alt="philosopher function" style="width:100%;height:100%;"></li>
        <li><img src="imgs/week5/d_ph_3.png" alt="philosopher function" style="width:100%;height:100%;"></li>
        <li>Firstly we should transfer this practical problem to an operating system related problem.
        Here philosphers are processes, forks are shared resources. Each philosopher could have
        different <strong>states</strong> indicates:
          <ol>
            <li><strong>EATING:</strong> Use number 2, the philsopher is eating using both folks</li>
            <li><strong>HUNGRY:</strong> Use number 1, the philosopher wants to eat but there isn't enough forks available</li>
            <li><strong>THINKING:</strong> Use number 0, the philosopher doesn't want to eat.</li>
          </ol>
        <li>We want to give a mutual exclusion when philosopher want to take or put the forks, thus there is one semaphore for each philosopher </li>
        <li>The algorithm works like this: run philosopher => try to <code>take_fork()</code>, set state to HUNGRY => use <code>test()</code> to check the availability of forks => if not availale be blocked at <code>down(&s[i])</code> / if available, set state to EATING, <code>up(&s[i])</code> would unblock the process if previously blocked by <code>down(&s[i]</code>).</li>
        <li> After <code>eat()</code>, we want to <code>put_forks()</code>, which change the state back to THINKING and <strong>try to activiate the neighbour who is previously being blocked because the forks are unavailable.</strong></li>
      </ul>
      <hr>
    </div>

	<div class="block" id="review_schedule">
      <h4>Some review before scheduling</h4>
      <ul>
        <li>Process: program in execution, contains all state of program in execution, named by PID </li>
        <li>State queues: one queue for each state, each PCB queued on a state queue according to current state, when PCB changes state, PCB unlinks from one queue and linked to another</li>
        <li>Process scheduling: one process can run on each CPU and scheduler decides which one to run. There are two goals of scheduling:
         <ol><li>max CPU utilization</li>
         	<li>give illusion that processes runing concurrently.</li></ol>
        <li>Process states: different event cause changes to a process state, which OS must record.</li>
        <li>Context Switch: switch CPU to another process
        	<ol>
            	<li>Saved currently running process statement (don't want to lose any data)</li>
                <li>Select next process from ready process</li>
                <li>Restore state of next process
                	<ul>
                    	<li>Restore register</li>
                        <li>Switch to user mode</li>
                        <li>Set PC to next instruction in this process</li>
                    </ul>
                </li>
        	</ol></li>
      </ul>
      <hr>
    </div>

    <div class="block" id="sheduling">
      <h4>Scheduling</h4>
      <ul>
        <li>Process life cycle, alternately switch between computation(CPU-burst) and I/O(I/O burst)</li>
        <li>CPU-bound: long CPU bursts, infrequent I/O burst</li>
        <li>I/O bound: short CPU bursts, frequent(long) I/O bursts. During I/O bursts, CPU not needed => opportunity to execute another process</li>
        <li><img src="imgs/week5/burst.png" alt="burst" style="width:100%;height:100%;"> a) CPU-bound process, b) I/O-bound process</li>
        <li>Processor scheduling is the allocation of processors to processes over time. Key to multiprogramming. </li>
        <li>Goals: fairness/ avoid starvation/ balance</li>
        <li>Two types of scheduling:
        	<ul>
            	<li>non-preemptive: CPU keeps working on one process until it terminates.</li>
                <li>preemptive: CPU can be taken from running process and allocated to another. Need in real-time systems.</li>
            </ul>
        </li>

        <li>Scheduling algorithms: FCFS
        	<ul>
            	<li>content</li>
                <li>Example</li>
                <li>Problem</li>
            </ul>
        </li>

        <li>Scheduling algorithms: SJF
        	<ul>
            	<li>content</li>
                <li>Example</li>
                <li>Problem</li>
            </ul>
        </li>

        <li>Scheduling algorithms: RR
        </li>

        <li>Priority queue</li>
        <li>Multi-level queue shceduling</li>
        <li>Feedback scheduling</li>
        <li>Linux 2.6 CPU scheduling</li>
      </ul>
    </div>
	</section>


  <section id="week5">
    <h3>WEEK5: Memory management</h3>

    <div class="block" id="memory">
      <h4>Memory management</h4>
      <ul>
        <li></li>
      </ul>
      <hr>
    </div>

    <div class="block" id="">
      <h4></h4>
      <ul>
        <li></li>
      </ul>
      <hr>
    </div>

    <div class="block" id="">
      <h4></h4>
      <ul>
        <li></li>
      </ul>
      <hr>
    </div>

    <div class="block" id="">
      <h4></h4>
      <ul>
        <li></li>
      </ul>
      <hr>
    </div>

  </section>

  <section id="Assignment 1">
    <h3>Assignment 1: System Calls and Monitoring Processes</h3>
    <div class="block" id="">
      <h4>Tips</h4>
      <ul>
        <li>I am mainly going to talk about my <strong>own</strong> feeling about the assignment, including what I think might be hard or easy, and some useful tips (maybe?)</li>
        <li>Find all official introduction and start code <a href="http://www.cdf.toronto.edu/~csc369h/summer/assignments/a1/a1.html">HERE</a>. Pls read <strong>several times</strong> with a very careful manner. You are fine if you can <strong>repeat all important instructions without looking at the original web page</strong>. Compare to other courses, CSC369 has a fairly long description telling you a lot about details. They are all important for writing the actual code.</li>
        <li>Understand all start code</li>
        <li>In general, you need to fill in X functions
        	<ul>
            	<li><code>interceptor</code> => Used to <strong>log</strong> message to all <strong>monitored</strong> function call, so we firstly make a check, and it the function is monitored, we write a function to log the message. </li>
                <li><code>my_syscall</code> => Core of the whole assignment. The goal is to implement 4 commands.
                	<ul>
                    	<li><code>REQUEST_SYSCALL_INTERCEPT</code></li>
                        <li><code>REQUEST_SYSCALL_RELEASE</code></li>
                        <li><code>REQUEST_START_MONITORING</code></li>
                        <li><code>REQUEST_STOP_MONITORING</code></li>
                    </ul> 
                    There are mainly two parts for this function, first is the error checking since there might be all different kinds of errors like syscall not valid, caller does not have right permissions, etc. We need to make sure there is no error before executing the four commands. The actual functionality part is not hard, since start code has already given most functins, we just need to combine them for our purpose. </li>
                    
            	<li><code>my_exit_group(int status)</code> => This function is used to replace original exit_group function. <a href="http://www.tutorialspoint.com/unix_system_calls/exit_group.htm">Exit group</a> works to terminate the current thread group. In our case,<strong> when a process exit, we want to remove its pid from all monitoring lists</strong>, so we have to explicitly write some code with give functions to achieve this goal. </li>

                <li><code>init_function</code> => Used for module initialization. By saying initialization we want to replace all system calls we want to hijack from the original system call table to our own. Of course we want to <strong>save a copy of the original system call</strong> so that we could resume it when we want to exit. Moreover we should change set system call table writable.</li>
                <li><code>exit_function</code> => Used for module exit. When exit we want to restore all of the original system call. Moreover we should set the system call table back to read only.</li>
            </ul>
        </li>
        <li>Pro tips:
        	<ul>
            	<li>Synchronization: </li>
                <li>struct pt_regs reg</li>
                <li></li>
            </ul>
        </li>
        <li>Test on virtual machine, might be tricky</li>
      </ul>
      <hr>
    </div>
  </section>

  <footer>
    <section class="block">
      <h4>footer</h4>
      <p>Posted by: YUE LI (RIO)</p>
      <p>Some notes are from my friend Ryan Yan</p>
      <p>Contact information: <a href="mailto:lhzuigao@hotmail.com">
        lhzuigao@hotmail.com</a></p>
      <p>©2016 YUE LI ALL RIGHTS RESERVED</p>
    </section>
  </footer>





</body>
